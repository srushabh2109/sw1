{
  "manifest": {
    "name": "redis",
    "version": "3.1.2",
    "description": "A high performance Redis client.",
    "keywords": [
      "database",
      "redis",
      "transaction",
      "pipelining",
      "performance",
      "queue",
      "nodejs",
      "pubsub",
      "backpressure"
    ],
    "author": {
      "name": "Matt Ranney",
      "email": "mjr@ranney.com"
    },
    "contributors": [
      {
        "name": "Mike Diarmid",
        "url": "Salakar"
      },
      {
        "name": "Ruben Bridgewater",
        "url": "BridgeAR"
      }
    ],
    "license": "MIT",
    "main": "./index.js",
    "scripts": {
      "coveralls": "nyc report --reporter=text-lcov | coveralls",
      "coverage": "nyc report --reporter=html",
      "benchmark": "node benchmarks/multi_bench.js",
      "test": "nyc --cache mocha ./test/*.spec.js ./test/commands/*.spec.js --timeout=8000 && npm run coverage",
      "lint": "eslint .",
      "lint:fix": "eslint . --fix",
      "lint:report": "eslint --output-file=eslint-report.json --format=json  .",
      "compare": "node benchmarks/diff_multi_bench_output.js beforeBench.txt afterBench.txt"
    },
    "dependencies": {
      "denque": "^1.5.0",
      "redis-commands": "^1.7.0",
      "redis-errors": "^1.2.0",
      "redis-parser": "^3.0.0"
    },
    "engines": {
      "node": ">=10"
    },
    "devDependencies": {
      "bluebird": "^3.7.2",
      "coveralls": "^3.1.0",
      "cross-spawn": "^7.0.3",
      "eslint": "^7.21.0",
      "intercept-stdout": "~0.1.2",
      "metrics": "^0.1.21",
      "mocha": "^8.3.0",
      "nyc": "^15.1.0",
      "prettier": "^2.2.1",
      "tcp-port-used": "^1.0.1",
      "uuid": "^8.3.2"
    },
    "repository": {
      "type": "git",
      "url": "git://github.com/NodeRedis/node-redis.git"
    },
    "bugs": {
      "url": "https://github.com/NodeRedis/node-redis/issues"
    },
    "homepage": "https://github.com/NodeRedis/node-redis",
    "funding": {
      "type": "opencollective",
      "url": "https://opencollective.com/node-redis"
    },
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-redis-3.1.2-766851117e80653d23e0ed536254677ab647638c-integrity/node_modules/redis/package.json",
    "readmeFilename": "README.md",
    "readme": "<p align=\"center\">\n    <a href=\"https://github.com/noderedis/node-redis/\">\n        <img width=\"190px\" src=\"https://static.invertase.io/assets/node_redis_logo.png\" />\n    </a>\n    <h2 align=\"center\">Node Redis</h2>\n    <h4 align=\"center\">A high performance Node.js Redis client.</h4>\n</p>\n\n---\n\n<p align=\"center\">\n    <a href=\"https://www.npmjs.com/package/redis\"><img src=\"https://img.shields.io/npm/dm/redis.svg\" alt=\"NPM downloads\"></a>\n    <a href=\"https://www.npmjs.com/package/redis\"><img src=\"https://img.shields.io/npm/v/redis.svg\" alt=\"NPM version\"></a>\n    <a href=\"https://github.com/NodeRedis/node-redis/actions?query=workflow%3ATests\"><img src=\"https://github.com/NodeRedis/node-redis/workflows/Tests/badge.svg\" alt=\"Build Status\" /></a>\n    <a href=\"https://github.com/NodeRedis/node-redis/actions?query=workflow%3A%22Tests+Windows%22\"><img src=\"https://github.com/NodeRedis/node-redis/workflows/Tests%20Windows/badge.svg\" alt=\"Windows Build Status\" /></a>\n    <a href=\"https://coveralls.io/r/NodeRedis/node-redis?branch=\"><img src=\"https://coveralls.io/repos/NodeRedis/node-redis/badge.svg?branch=master\" alt=\"Coverage Status\" /></a>\n    <a href=\"https://codeclimate.com/github/NodeRedis/node-redis/maintainability\"><img src=\"https://api.codeclimate.com/v1/badges/f6d7063243c234237e73/maintainability\" /></a>\n    <a href=\"https://lgtm.com/projects/g/NodeRedis/node-redis/context:javascript\"><img src=\"https://img.shields.io/lgtm/grade/javascript/g/NodeRedis/node-redis.svg?logo=lgtm&logoWidth=18\" alt=\"Coverage Status\" /></a>\n    <a href=\"https://discord.gg/XMMVgxUm\"><img src=\"https://img.shields.io/discord/697882427875393627?style=flat-square\" /></a>\n</p>\n\n---\n\n## Installation\n\n```bash\nnpm install redis\n```\n\n## Usage\n\n#### Example\n\n```js\nconst redis = require(\"redis\");\nconst client = redis.createClient();\n\nclient.on(\"error\", function(error) {\n  console.error(error);\n});\n\nclient.set(\"key\", \"value\", redis.print);\nclient.get(\"key\", redis.print);\n```\n\nNote that the API is entirely asynchronous. To get data back from the server,\nyou'll need to use a callback.\n\n### Promises\n\nNode Redis currently doesn't natively support promises (this is coming in v4), however you can wrap the methods you\nwant to use with promises using the built-in Node.js `util.promisify` method on Node.js >= v8;\n\n```js\nconst { promisify } = require(\"util\");\nconst getAsync = promisify(client.get).bind(client);\n\ngetAsync.then(console.log).catch(console.error);\n```\n\n### Commands\n\nThis library is a 1 to 1 mapping of the [Redis commands](https://redis.io/commands).\n\nEach Redis command is exposed as a function on the `client` object.\nAll functions take either an `args` Array plus optional `callback` Function or\na variable number of individual arguments followed by an optional callback.\nExamples:\n\n```js\nclient.hmset([\"key\", \"foo\", \"bar\"], function(err, res) {\n  // ...\n});\n\n// Works the same as\nclient.hmset(\"key\", [\"foo\", \"bar\"], function(err, res) {\n  // ...\n});\n\n// Or\nclient.hmset(\"key\", \"foo\", \"bar\", function(err, res) {\n  // ...\n});\n```\n\nCare should be taken with user input if arrays are possible (via body-parser, query string or other method), as single arguments could be unintentionally interpreted as multiple args.\n\nNote that in either form the `callback` is optional:\n\n```js\nclient.set(\"foo\", \"bar\");\nclient.set([\"hello\", \"world\"]);\n```\n\nIf the key is missing, reply will be null. Only if the [Redis Command\nReference](http://redis.io/commands) states something else it will not be null.\n\n```js\nclient.get(\"missing_key\", function(err, reply) {\n  // reply is null when the key is missing\n  console.log(reply);\n});\n```\n\nMinimal parsing is done on the replies. Commands that return a integer return\nJavaScript Numbers, arrays return JavaScript Array. `HGETALL` returns an Object\nkeyed by the hash keys. All strings will either be returned as string or as\nbuffer depending on your setting. Please be aware that sending null, undefined\nand Boolean values will result in the value coerced to a string!\n\n## API\n\n### Connection and other Events\n\n`client` will emit some events about the state of the connection to the Redis server.\n\n#### `\"ready\"`\n\n`client` will emit `ready` once a connection is established. Commands issued\nbefore the `ready` event are queued, then replayed just before this event is\nemitted.\n\n#### `\"connect\"`\n\n`client` will emit `connect` as soon as the stream is connected to the server.\n\n#### `\"reconnecting\"`\n\n`client` will emit `reconnecting` when trying to reconnect to the Redis server\nafter losing the connection. Listeners are passed an object containing `delay`\n(in ms from the previous try) and `attempt` (the attempt #) attributes.\n\n#### `\"error\"`\n\n`client` will emit `error` when encountering an error connecting to the Redis\nserver or when any other in Node Redis occurs. If you use a command without\ncallback and encounter a ReplyError it is going to be emitted to the error\nlistener.\n\nSo please attach the error listener to Node Redis.\n\n#### `\"end\"`\n\n`client` will emit `end` when an established Redis server connection has closed.\n\n#### `\"warning\"`\n\n`client` will emit `warning` when password was set but none is needed and if a\ndeprecated option / function / similar is used.\n\n### redis.createClient()\n\nIf you have `redis-server` running on the same machine as node, then the\ndefaults for port and host are probably fine and you don't need to supply any\narguments. `createClient()` returns a `RedisClient` object. Otherwise,\n`createClient()` accepts these arguments:\n\n- `redis.createClient([options])`\n- `redis.createClient(unix_socket[, options])`\n- `redis.createClient(redis_url[, options])`\n- `redis.createClient(port[, host][, options])`\n\n**Tip:** If the Redis server runs on the same machine as the client consider\nusing unix sockets if possible to increase throughput.\n\n**Note:** Using `'rediss://...` for the protocol in a `redis_url` will enable a TLS socket connection. However, additional TLS options will need to be passed in `options`, if required.\n\n#### `options` object properties\n\n| Property                   | Default   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| -------------------------- | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| host                       | 127.0.0.1 | IP address of the Redis server                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| port                       | 6379      | Port of the Redis server                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| path                       | null      | The UNIX socket string of the Redis server                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| url                        | null      | The URL of the Redis server. Format: `[redis[s]:]//[[user][:password@]][host][:port][/db-number][?db=db-number[&password=bar[&option=value]]]` (More info avaliable at [IANA](http://www.iana.org/assignments/uri-schemes/prov/redis)).                                                                                                                                                                                                                                                                                                                                       |\n| string_numbers             | null      | Set to `true`, Node Redis will return Redis number values as Strings instead of javascript Numbers. Useful if you need to handle big numbers (above `Number.MAX_SAFE_INTEGER === 2^53`). Hiredis is incapable of this behavior, so setting this option to `true` will result in the built-in javascript parser being used no matter the value of the `parser` option.                                                                                                                                                                                                         |\n| return_buffers             | false     | If set to `true`, then all replies will be sent to callbacks as Buffers instead of Strings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| detect_buffers             | false     | If set to `true`, then replies will be sent to callbacks as Buffers. This option lets you switch between Buffers and Strings on a per-command basis, whereas `return_buffers` applies to every command on a client. **Note**: This doesn't work properly with the pubsub mode. A subscriber has to either always return Strings or Buffers.                                                                                                                                                                                                                                   |\n| socket_keepalive           | true      | If set to `true`, the keep-alive functionality is enabled on the underlying socket.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| socket_initial_delay       | 0         | Initial Delay in milliseconds, and this will also behave the interval keep alive message sending to Redis.                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| no_ready_check             | false     | When a connection is established to the Redis server, the server might still be loading the database from disk. While loading, the server will not respond to any commands. To work around this, Node Redis has a \"ready check\" which sends the `INFO` command to the server. The response from the `INFO` command indicates whether the server is ready for more commands. When ready, `node_redis` emits a `ready` event. Setting `no_ready_check` to `true` will inhibit this check.                                                                                       |\n| enable_offline_queue       | true      | By default, if there is no active connection to the Redis server, commands are added to a queue and are executed once the connection has been established. Setting `enable_offline_queue` to `false` will disable this feature and the callback will be executed immediately with an error, or an error will be emitted if no callback is specified.                                                                                                                                                                                                                          |\n| retry_unfulfilled_commands | false     | If set to `true`, all commands that were unfulfilled while the connection is lost will be retried after the connection has been reestablished. Use this with caution if you use state altering commands (e.g. `incr`). This is especially useful if you use blocking commands.                                                                                                                                                                                                                                                                                                |\n| password                   | null      | If set, client will run Redis auth command on connect. Alias `auth_pass` **Note** Node Redis < 2.5 must use `auth_pass`                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| user                       | null      | The ACL user (only valid when `password` is set)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| db                         | null      | If set, client will run Redis `select` command on connect.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| family                     | IPv4      | You can force using IPv6 if you set the family to 'IPv6'. See Node.js [net](https://nodejs.org/api/net.html) or [dns](https://nodejs.org/api/dns.html) modules on how to use the family type.                                                                                                                                                                                                                                                                                                                                                                                 |\n| disable_resubscribing      | false     | If set to `true`, a client won't resubscribe after disconnecting.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| rename_commands            | null      | Passing an object with renamed commands to use instead of the original functions. For example, if you renamed the command KEYS to \"DO-NOT-USE\" then the rename_commands object would be: `{ KEYS : \"DO-NOT-USE\" }` . See the [Redis security topics](http://redis.io/topics/security) for more info.                                                                                                                                                                                                                                                                          |\n| tls                        | null      | An object containing options to pass to [tls.connect](http://nodejs.org/api/tls.html#tls_tls_connect_port_host_options_callback) to set up a TLS connection to Redis (if, for example, it is set up to be accessible via a tunnel).                                                                                                                                                                                                                                                                                                                                           |\n| prefix                     | null      | A string used to prefix all used keys (e.g. `namespace:test`). Please be aware that the `keys` command will not be prefixed. The `keys` command has a \"pattern\" as argument and no key and it would be impossible to determine the existing keys in Redis if this would be prefixed.                                                                                                                                                                                                                                                                                          |\n| retry_strategy             | function  | A function that receives an options object as parameter including the retry `attempt`, the `total_retry_time` indicating how much time passed since the last time connected, the `error` why the connection was lost and the number of `times_connected` in total. If you return a number from this function, the retry will happen exactly after that time in milliseconds. If you return a non-number, no further retry will happen and all offline commands are flushed with errors. Return an error to return that specific error to all offline commands. Example below. |\n| connect_timeout            | 3600000   | In milliseconds. This should only be the timeout for connecting to redis, but for now it interferes with `retry_strategy` and stops it from reconnecting after this timeout.                                                                                                                                                                                                                                                                                                                                                                                                  |\n\n**`detect_buffers` example:**\n\n```js\nconst redis = require(\"redis\");\nconst client = redis.createClient({ detect_buffers: true });\n\nclient.set(\"foo_rand000000000000\", \"OK\");\n\n// This will return a JavaScript String\nclient.get(\"foo_rand000000000000\", function(err, reply) {\n  console.log(reply.toString()); // Will print `OK`\n});\n\n// This will return a Buffer since original key is specified as a Buffer\nclient.get(new Buffer(\"foo_rand000000000000\"), function(err, reply) {\n  console.log(reply.toString()); // Will print `<Buffer 4f 4b>`\n});\n```\n\n**`retry_strategy` example:**\n\n```js\nconst client = redis.createClient({\n  retry_strategy: function(options) {\n    if (options.error && options.error.code === \"ECONNREFUSED\") {\n      // End reconnecting on a specific error and flush all commands with\n      // a individual error\n      return new Error(\"The server refused the connection\");\n    }\n    if (options.total_retry_time > 1000 * 60 * 60) {\n      // End reconnecting after a specific timeout and flush all commands\n      // with a individual error\n      return new Error(\"Retry time exhausted\");\n    }\n    if (options.attempt > 10) {\n      // End reconnecting with built in error\n      return undefined;\n    }\n    // reconnect after\n    return Math.min(options.attempt * 100, 3000);\n  },\n});\n```\n\n### client.auth(password[, callback])\n\nWhen connecting to a Redis server that requires authentication, the `AUTH`\ncommand must be sent as the first command after connecting. This can be tricky\nto coordinate with reconnections, the ready check, etc. To make this easier,\n`client.auth()` stashes `password` and will send it after each connection,\nincluding reconnections. `callback` is invoked only once, after the response to\nthe very first `AUTH` command sent.\nNOTE: Your call to `client.auth()` should not be inside the ready handler. If\nyou are doing this wrong, `client` will emit an error that looks\nsomething like this `Error: Ready check failed: ERR operation not permitted`.\n\n### client.quit(callback)\n\nThis sends the quit command to the redis server and ends cleanly right after all\nrunning commands were properly handled. If this is called while reconnecting\n(and therefore no connection to the redis server exists) it is going to end the\nconnection right away instead of resulting in further reconnections! All offline\ncommands are going to be flushed with an error in that case.\n\n### client.end(flush)\n\nForcibly close the connection to the Redis server. Note that this does not wait\nuntil all replies have been parsed. If you want to exit cleanly, call\n`client.quit()` as mentioned above.\n\nYou should set flush to true, if you are not absolutely sure you do not care\nabout any other commands. If you set flush to false all still running commands\nwill silently fail.\n\nThis example closes the connection to the Redis server before the replies have\nbeen read. You probably don't want to do this:\n\n```js\nconst redis = require(\"redis\");\nconst client = redis.createClient();\n\nclient.set(\"hello\", \"world\", function(err) {\n  // This will either result in an error (flush parameter is set to true)\n  // or will silently fail and this callback will not be called at all (flush set to false)\n  console.error(err);\n});\n\n// No further commands will be processed\nclient.end(true);\n\nclient.get(\"hello\", function(err) {\n  console.error(err); // => 'The connection has already been closed.'\n});\n```\n\n`client.end()` without the flush parameter set to true should NOT be used in production!\n\n### Error Handling\n\nCurrently the following `Error` subclasses exist:\n\n- `RedisError`: _All errors_ returned by the client\n- `ReplyError` subclass of `RedisError`: All errors returned by **Redis** itself\n- `AbortError` subclass of `RedisError`: All commands that could not finish due\n  to what ever reason\n- `ParserError` subclass of `RedisError`: Returned in case of a parser error\n  (this should not happen)\n- `AggregateError` subclass of `AbortError`: Emitted in case multiple unresolved\n  commands without callback got rejected in debug_mode instead of lots of\n  `AbortError`s.\n\nAll error classes are exported by the module.\n\n#### Example\n\n```js\nconst assert = require(\"assert\");\n\nconst redis = require(\"redis\");\nconst { AbortError, AggregateError, ReplyError } = require(\"redis\");\n\nconst client = redis.createClient();\n\nclient.on(\"error\", function(err) {\n  assert(err instanceof Error);\n  assert(err instanceof AbortError);\n  assert(err instanceof AggregateError);\n\n  // The set and get are aggregated in here\n  assert.strictEqual(err.errors.length, 2);\n  assert.strictEqual(err.code, \"NR_CLOSED\");\n});\n\nclient.set(\"foo\", \"bar\", \"baz\", function(err, res) {\n  // Too many arguments\n  assert(err instanceof ReplyError); // => true\n  assert.strictEqual(err.command, \"SET\");\n  assert.deepStrictEqual(err.args, [\"foo\", 123, \"bar\"]);\n\n  redis.debug_mode = true;\n\n  client.set(\"foo\", \"bar\");\n  client.get(\"foo\");\n\n  process.nextTick(function() {\n    // Force closing the connection while the command did not yet return\n    client.end(true);\n    redis.debug_mode = false;\n  });\n});\n```\n\nEvery `ReplyError` contains the `command` name in all-caps and the arguments (`args`).\n\nIf Node Redis emits a library error because of another error, the triggering\nerror is added to the returned error as `origin` attribute.\n\n**_Error codes_**\n\nNode Redis returns a `NR_CLOSED` error code if the clients connection dropped.\nIf a command unresolved command got rejected a `UNCERTAIN_STATE` code is\nreturned. A `CONNECTION_BROKEN` error code is used in case Node Redis gives up\nto reconnect.\n\n### client.unref()\n\nCall `unref()` on the underlying socket connection to the Redis server, allowing\nthe program to exit once no more commands are pending.\n\nThis is an **experimental** feature, and only supports a subset of the Redis\nprotocol. Any commands where client state is saved on the Redis server, e.g.\n`*SUBSCRIBE` or the blocking `BL*` commands will _NOT_ work with `.unref()`.\n\n```js\nconst redis = require(\"redis\");\nconst client = redis.createClient();\n\n/*\n * Calling unref() will allow this program to exit immediately after the get\n * command finishes. Otherwise the client would hang as long as the\n * client-server connection is alive.\n */\nclient.unref();\n\nclient.get(\"foo\", function(err, value) {\n  if (err) throw err;\n  console.log(value);\n});\n```\n\n### Hash Commands\n\nMost Redis commands take a single String or an Array of Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. When\ndealing with hash values, there are a couple of useful exceptions to this.\n\n#### client.hgetall(hash, callback)\n\nThe reply from an `HGETALL` command will be converted into a JavaScript Object. That way you can interact with the \nresponses using JavaScript syntax.\n\n**Example:**\n\n```js\nclient.hmset(\"key\", \"foo\", \"bar\", \"hello\", \"world\");\n\nclient.hgetall(\"key\", function(err, value) {\n  console.log(value.foo); // > \"bar\"\n  console.log(value.hello); // > \"world\"\n});\n```\n\n#### client.hmset(hash, key1, val1, ...keyN, valN, [callback])\n\nMultiple values may also be set by supplying more arguments.\n\n**Example:**\n\n```js\n//  key\n//    1) foo   => bar\n//    2) hello => world\nclient.HMSET(\"key\", \"foo\", \"bar\", \"hello\", \"world\");\n```\n\n### PubSub\n\n#### Example\n\nThis example opens two client connections, subscribes to a channel on one of them, and publishes to that\nchannel on the other.\n\n```js\nconst redis = require(\"redis\");\n\nconst subscriber = redis.createClient();\nconst publisher = redis.createClient();\n\nlet messageCount = 0;\n\nsubscriber.on(\"subscribe\", function(channel, count) {\n  publisher.publish(\"a channel\", \"a message\");\n  publisher.publish(\"a channel\", \"another message\");\n});\n\nsubscriber.on(\"message\", function(channel, message) {\n  messageCount += 1;\n\n  console.log(\"Subscriber received message in channel '\" + channel + \"': \" + message);\n\n  if (messageCount === 2) {\n    subscriber.unsubscribe();\n    subscriber.quit();\n    publisher.quit();\n  }\n});\n\nsubscriber.subscribe(\"a channel\");\n```\n\nWhen a client issues a `SUBSCRIBE` or `PSUBSCRIBE`, that connection is put into\na `\"subscriber\"` mode. At that point, the only valid commands are those that modify the subscription\nset, and quit (also ping on some redis versions). When\nthe subscription set is empty, the connection is put back into regular mode.\n\nIf you need to send regular commands to Redis while in subscriber mode, just\nopen another connection with a new client (use `client.duplicate()` to quickly duplicate an existing client).\n\n#### Subscriber Events\n\nIf a client has subscriptions active, it may emit these events:\n\n**\"message\" (channel, message)**:\n\nClient will emit `message` for every message received that matches an active subscription.\nListeners are passed the channel name as `channel` and the message as `message`.\n\n**\"pmessage\" (pattern, channel, message)**:\n\nClient will emit `pmessage` for every message received that matches an active\nsubscription pattern. Listeners are passed the original pattern used with\n`PSUBSCRIBE` as `pattern`, the sending channel name as `channel`, and the\nmessage as `message`.\n\n**\"message_buffer\" (channel, message)**:\n\nThis is the same as the `message` event with the exception, that it is always\ngoing to emit a buffer. If you listen to the `message` event at the same time as\nthe `message_buffer`, it is always going to emit a string.\n\n**\"pmessage_buffer\" (pattern, channel, message)**:\n\nThis is the same as the `pmessage` event with the exception, that it is always\ngoing to emit a buffer. If you listen to the `pmessage` event at the same time\nas the `pmessage_buffer`, it is always going to emit a string.\n\n**\"subscribe\" (channel, count)**:\n\nClient will emit `subscribe` in response to a `SUBSCRIBE` command. Listeners are\npassed the channel name as `channel` and the new count of subscriptions for this\nclient as `count`.\n\n**\"psubscribe\" (pattern, count)**:\n\nClient will emit `psubscribe` in response to a `PSUBSCRIBE` command. Listeners\nare passed the original pattern as `pattern`, and the new count of subscriptions\nfor this client as `count`.\n\n**\"unsubscribe\" (channel, count)**:\n\nClient will emit `unsubscribe` in response to a `UNSUBSCRIBE` command. Listeners\nare passed the channel name as `channel` and the new count of subscriptions for\nthis client as `count`. When `count` is 0, this client has left subscriber mode\nand no more subscriber events will be emitted.\n\n**\"punsubscribe\" (pattern, count)**:\n\nClient will emit `punsubscribe` in response to a `PUNSUBSCRIBE` command.\nListeners are passed the channel name as `channel` and the new count of\nsubscriptions for this client as `count`. When `count` is 0, this client has\nleft subscriber mode and no more subscriber events will be emitted.\n\n### client.multi([commands])\n\n`MULTI` commands are queued up until an `EXEC` is issued, and then all commands\nare run atomically by Redis. The interface returns an\nindividual `Multi` object by calling `client.multi()`. If any command fails to\nqueue, all commands are rolled back and none is going to be executed (For\nfurther information see the [Redis transactions](http://redis.io/topics/transactions) documentation).\n\n```js\nconst redis = require(\"redis\");\nconst client = redis.createClient();\n\nlet setSize = 20;\n\nclient.sadd(\"key\", \"member1\");\nclient.sadd(\"key\", \"member2\");\n\nwhile (setSize > 0) {\n  client.sadd(\"key\", \"member\" + setSize);\n  setSize -= 1;\n}\n\n// chain commands\nclient\n  .multi()\n  .scard(\"key\")\n  .smembers(\"key\")\n  .keys(\"*\")\n  .dbsize()\n  .exec(function(err, replies) {\n    console.log(\"MULTI got \" + replies.length + \" replies\");\n    replies.forEach(function(reply, index) {\n      console.log(\"REPLY  @ index \" + index + \": \" + reply.toString());\n    });\n  });\n```\n\n#### Multi.exec([callback])\n\n`client.multi()` is a constructor that returns a `Multi` object. `Multi` objects\nshare all of the same command methods as `client` objects do. Commands are\nqueued up inside the `Multi` object until `Multi.exec()` is invoked.\n\nIf your code contains an syntax error an `EXECABORT` error is going to be thrown\nand all commands are going to be aborted. That error contains a `.errors`\nproperty that contains the concrete errors.\nIf all commands were queued successfully and an error is thrown by redis while\nprocessing the commands that error is going to be returned in the result array!\nNo other command is going to be aborted though than the ones failing.\n\nYou can either chain together `MULTI` commands as in the above example, or you\ncan queue individual commands while still sending regular client command as in\nthis example:\n\n```js\nconst redis = require(\"redis\");\nconst client = redis.createClient();\n\n// start a separate multi command queue\nconst multi = client.multi();\n\n// add some commands to the queue\nmulti.incr(\"count_cats\", redis.print);\nmulti.incr(\"count_dogs\", redis.print);\n\n// runs a command immediately outside of the `multi` instance\nclient.mset(\"count_cats\", 100, \"count_dogs\", 50, redis.print);\n\n// drains the multi queue and runs each command atomically\nmulti.exec(function(err, replies) {\n  console.log(replies); // 101, 51\n});\n```\n\nIn addition to adding commands to the `MULTI` queue individually, you can also\npass an array of commands and arguments to the constructor:\n\n```js\nconst redis = require(\"redis\");\n\nconst client = redis.createClient();\n\nclient\n  .multi([\n    [\"mget\", \"foo\", \"bar\", redis.print],\n    [\"incr\", \"hello\"],\n  ])\n  .exec(function(err, replies) {\n    console.log(replies);\n  });\n```\n\n#### Multi.exec_atomic([callback])\n\nIdentical to Multi.exec but with the difference that executing a single command\nwill not use transactions.\n\n#### Optimistic Locks\n\nUsing `multi` you can make sure your modifications run as a transaction, but you\ncan't be sure you got there first. What if another client modified a key while\nyou were working with it's data?\n\nTo solve this, Redis supports the [WATCH](https://redis.io/topics/transactions)\ncommand, which is meant to be used with MULTI:\n\n```js\nconst redis = require(\"redis\");\n\nconst client = redis.createClient();\n\nclient.watch(\"foo\", function(watchError) {\n  if (watchError) throw watchError;\n\n  client.get(\"foo\", function(getError, result) {\n    if (getError) throw getError;\n\n    // Process result\n    // Heavy and time consuming operation here to generate \"bar\"\n\n    client\n      .multi()\n      .set(\"foo\", \"bar\")\n      .exec(function(execError, results) {\n        /**\n         * If err is null, it means Redis successfully attempted\n         * the operation.\n         */\n        if (execError) throw execError;\n\n        /**\n         * If results === null, it means that a concurrent client\n         * changed the key while we were processing it and thus\n         * the execution of the MULTI command was not performed.\n         *\n         * NOTICE: Failing an execution of MULTI is not considered\n         * an error. So you will have err === null and results === null\n         */\n      });\n  });\n});\n```\n\nThe above snippet shows the correct usage of `watch` with `multi`. Every time a\nwatched key is changed before the execution of a `multi` command, the execution\nwill return `null`. On a normal situation, the execution will return an array of\nvalues with the results of the operations.\n\nAs stated in the snippet, failing the execution of a `multi` command being watched\nis not considered an error. The execution may return an error if, for example, the\nclient cannot connect to Redis.\n\nAn example where we can see the execution of a `multi` command fail is as follows:\n\n```js\nconst clients = {\n  watcher: redis.createClient(),\n  modifier: redis.createClient(),\n};\n\nclients.watcher.watch(\"foo\", function(watchError) {\n  if (watchError) throw watchError;\n\n  // if you comment out the next line, the transaction will work\n  clients.modifier.set(\"foo\", Math.random(), setError => {\n    if (setError) throw setError;\n  });\n\n  // using a setTimeout here to ensure that the MULTI/EXEC will come after the SET.\n  // Normally, you would use a callback to ensure order, but I want the above SET command\n  // to be easily comment-out-able.\n  setTimeout(function() {\n    clients.watcher\n      .multi()\n      .set(\"foo\", \"bar\")\n      .set(\"hello\", \"world\")\n      .exec((multiExecError, results) => {\n        if (multiExecError) throw multiExecError;\n\n        if (results === null) {\n          console.log(\"transaction aborted because results were null\");\n        } else {\n          console.log(\"transaction worked and returned\", results);\n        }\n\n        clients.watcher.quit();\n        clients.modifier.quit();\n      });\n  }, 1000);\n});\n```\n\n#### `WATCH` limitations\n\nRedis WATCH works only on _whole_ key values. For example, with WATCH you can\nwatch a hash for modifications, but you cannot watch a specific field of a hash.\n\nThe following example would watch the keys `foo` and `hello`, not the field `hello`\nof hash `foo`:\n\n```js\nconst redis = require(\"redis\");\n\nconst client = redis.createClient();\n\nclient.hget(\"foo\", \"hello\", function(hashGetError, result) {\n  if (hashGetError) throw hashGetError;\n\n  //Do some processing with the value from this field and watch it after\n\n  client.watch(\"foo\", \"hello\", function(watchError) {\n    if (watchError) throw watchError;\n\n    /**\n     * This is now watching the keys 'foo' and 'hello'. It is not\n     * watching the field 'hello' of hash 'foo'. Because the key 'foo'\n     * refers to a hash, this command is now watching the entire hash\n     * for modifications.\n     */\n  });\n});\n```\n\nThis limitation also applies to sets (you can not watch individual set members)\nand any other collections.\n\n### client.batch([commands])\n\nIdentical to `.multi()` without transactions. This is recommended if you want to\nexecute many commands at once but don't need to rely on transactions.\n\n`BATCH` commands are queued up until an `EXEC` is issued, and then all commands\nare run atomically by Redis. The interface returns an\nindividual `Batch` object by calling `client.batch()`. The only difference\nbetween .batch and .multi is that no transaction is going to be used.\nBe aware that the errors are - just like in multi statements - in the result.\nOtherwise both, errors and results could be returned at the same time.\n\nIf you fire many commands at once this is going to boost the execution speed\nsignificantly compared to firing the same commands in a loop without waiting for\nthe result! See the benchmarks for further comparison. Please remember that all\ncommands are kept in memory until they are fired.\n\n### Monitor mode\n\nRedis supports the `MONITOR` command, which lets you see all commands received\nby the Redis server across all client connections, including from other client\nlibraries and other computers.\n\nA `monitor` event is going to be emitted for every command fired from any client\nconnected to the server including the monitoring client itself. The callback for\nthe `monitor` event takes a timestamp from the Redis server, an array of command\narguments and the raw monitoring string.\n\n#### Example:\n\n```js\nconst redis = require(\"redis\");\nconst client = redis.createClient();\n\nclient.monitor(function(err, res) {\n  console.log(\"Entering monitoring mode.\");\n});\n\nclient.set(\"foo\", \"bar\");\n\nclient.on(\"monitor\", function(time, args, rawReply) {\n  console.log(time + \": \" + args); // 1458910076.446514:['set', 'foo', 'bar']\n});\n```\n\n## Extras\n\nSome other things you might find useful.\n\n### `client.server_info`\n\nAfter the ready probe completes, the results from the INFO command are saved in\nthe `client.server_info` object.\n\nThe `versions` key contains an array of the elements of the version string for\neasy comparison.\n\n```\n> client.server_info.redis_version\n'2.3.0'\n> client.server_info.versions\n[ 2, 3, 0 ]\n```\n\n### `redis.print()`\n\nA handy callback function for displaying return values when testing. Example:\n\n```js\nconst redis = require(\"redis\");\nconst client = redis.createClient();\n\nclient.on(\"connect\", function() {\n  client.set(\"foo\", \"bar\", redis.print); // => \"Reply: OK\"\n  client.get(\"foo\", redis.print); // => \"Reply: bar\"\n  client.quit();\n});\n```\n\n### Multi-word commands\n\nTo execute redis multi-word commands like `SCRIPT LOAD` or `CLIENT LIST` pass\nthe second word as first parameter:\n\n```js\nclient.script(\"load\", \"return 1\");\n\nclient\n  .multi()\n  .script(\"load\", \"return 1\")\n  .exec();\n\nclient.multi([[\"script\", \"load\", \"return 1\"]]).exec();\n```\n\n### `client.duplicate([options][, callback])`\n\nDuplicate all current options and return a new redisClient instance. All options\npassed to the duplicate function are going to replace the original option. If\nyou pass a callback, duplicate is going to wait until the client is ready and\nreturns it in the callback. If an error occurs in the meanwhile, that is going\nto return an error instead in the callback.\n\nOne example of when to use duplicate() would be to accommodate the connection-\nblocking redis commands `BRPOP`, `BLPOP`, and `BRPOPLPUSH`. If these commands\nare used on the same Redis client instance as non-blocking commands, the\nnon-blocking ones may be queued up until after the blocking ones finish.\n\nAnother reason to use duplicate() is when multiple DBs on the same server are\naccessed via the redis SELECT command. Each DB could use its own connection.\n\n### `client.sendCommand(command_name[, [args][, callback]])`\n\nAll Redis commands have been added to the `client` object. However, if new\ncommands are introduced before this library is updated or if you want to add\nindividual commands you can use `sendCommand()` to send arbitrary commands to\nRedis.\n\nAll commands are sent as multi-bulk commands. `args` can either be an Array of\narguments, or omitted / set to undefined.\n\n### `redis.addCommand(command_name)`\n\nCalling addCommand will add a new command to the prototype. The exact command\nname will be used when calling using this new command. Using arbitrary arguments\nis possible as with any other command.\n\n### `client.connected`\n\nBoolean tracking the state of the connection to the Redis server.\n\n### `client.command_queue_length`\n\nThe number of commands that have been sent to the Redis server but not yet\nreplied to. You can use this to enforce some kind of maximum queue depth for\ncommands while connected.\n\n### `client.offline_queue_length`\n\nThe number of commands that have been queued up for a future connection. You can\nuse this to enforce some kind of maximum queue depth for pre-connection\ncommands.\n\n### Commands with Optional and Keyword arguments\n\nThis applies to anything that uses an optional `[WITHSCORES]` or `[LIMIT offset count]` in the [redis.io/commands](http://redis.io/commands) documentation.\n\n#### Example\n\n```js\nconst args = [\"myzset\", 1, \"one\", 2, \"two\", 3, \"three\", 99, \"ninety-nine\"];\n\nclient.zadd(args, function(addError, addResponse) {\n  if (addError) throw addError;\n  console.log(\"added \" + addResponse + \" items.\");\n\n  // -Infinity and +Infinity also work\n  const args1 = [\"myzset\", \"+inf\", \"-inf\"];\n  client.zrevrangebyscore(args1, function(rangeError, rangeResponse) {\n    if (rangeError) throw rangeError;\n    console.log(\"response1\", rangeResponse);\n    // ...\n  });\n\n  const max = 3;\n  const min = 1;\n  const offset = 1;\n  const count = 2;\n  const args2 = [\"myzset\", max, min, \"WITHSCORES\", \"LIMIT\", offset, count];\n  client.zrevrangebyscore(args2, function(rangeError, rangeResponse) {\n    if (rangeError) throw rangeError;\n    console.log(\"response2\", rangeResponse);\n    // ...\n  });\n});\n```\n\n## Performance\n\nMuch effort has been spent to make Node Redis as fast as possible for common operations.\n\n```\nMac mini (2018), i7-3.2GHz and 32gb memory\nclients: 1, NodeJS: 12.15.0, Redis: 5.0.6, parser: javascript, connected by: tcp\n         PING,         1/1 avg/max:   0.03/  3.28 2501ms total,   31926 ops/sec\n         PING,  batch 50/1 avg/max:   0.08/  3.35 2501ms total,  599460 ops/sec\n   SET 4B str,         1/1 avg/max:   0.03/  3.54 2501ms total,   29483 ops/sec\n   SET 4B str,  batch 50/1 avg/max:   0.10/  1.39 2501ms total,  477689 ops/sec\n   SET 4B buf,         1/1 avg/max:   0.04/  1.52 2501ms total,   23449 ops/sec\n   SET 4B buf,  batch 50/1 avg/max:   0.20/  2.09 2501ms total,  244382 ops/sec\n   GET 4B str,         1/1 avg/max:   0.03/  1.35 2501ms total,   32205 ops/sec\n   GET 4B str,  batch 50/1 avg/max:   0.09/  2.02 2501ms total,  568992 ops/sec\n   GET 4B buf,         1/1 avg/max:   0.03/  2.93 2501ms total,   32802 ops/sec\n   GET 4B buf,  batch 50/1 avg/max:   0.08/  1.03 2501ms total,  592863 ops/sec\n SET 4KiB str,         1/1 avg/max:   0.03/  0.76 2501ms total,   29287 ops/sec\n SET 4KiB str,  batch 50/1 avg/max:   0.35/  2.97 2501ms total,  143163 ops/sec\n SET 4KiB buf,         1/1 avg/max:   0.04/  1.21 2501ms total,   23070 ops/sec\n SET 4KiB buf,  batch 50/1 avg/max:   0.28/  2.34 2501ms total,  176809 ops/sec\n GET 4KiB str,         1/1 avg/max:   0.03/  1.54 2501ms total,   29555 ops/sec\n GET 4KiB str,  batch 50/1 avg/max:   0.18/  1.59 2501ms total,  279188 ops/sec\n GET 4KiB buf,         1/1 avg/max:   0.03/  1.80 2501ms total,   30681 ops/sec\n GET 4KiB buf,  batch 50/1 avg/max:   0.17/  5.00 2501ms total,  285886 ops/sec\n         INCR,         1/1 avg/max:   0.03/  1.99 2501ms total,   32757 ops/sec\n         INCR,  batch 50/1 avg/max:   0.09/  2.54 2501ms total,  538964 ops/sec\n        LPUSH,         1/1 avg/max:   0.05/  4.85 2501ms total,   19482 ops/sec\n        LPUSH,  batch 50/1 avg/max:   0.12/  9.52 2501ms total,  395562 ops/sec\n    LRANGE 10,         1/1 avg/max:   0.06/  9.21 2501ms total,   17062 ops/sec\n    LRANGE 10,  batch 50/1 avg/max:   0.22/  1.03 2501ms total,  228269 ops/sec\n   LRANGE 100,         1/1 avg/max:   0.05/  1.44 2501ms total,   19051 ops/sec\n   LRANGE 100,  batch 50/1 avg/max:   0.99/  3.46 2501ms total,   50480 ops/sec\n SET 4MiB str,         1/1 avg/max:   4.11/ 13.96 2501ms total,     243 ops/sec\n SET 4MiB str,  batch 20/1 avg/max:  91.16/145.01 2553ms total,     219 ops/sec\n SET 4MiB buf,         1/1 avg/max:   2.81/ 11.90 2502ms total,     354 ops/sec\n SET 4MiB buf,  batch 20/1 avg/max:  36.21/ 70.96 2535ms total,     552 ops/sec\n GET 4MiB str,         1/1 avg/max:   2.82/ 19.10 2503ms total,     354 ops/sec\n GET 4MiB str,  batch 20/1 avg/max: 128.57/207.86 2572ms total,     156 ops/sec\n GET 4MiB buf,         1/1 avg/max:   3.13/ 23.88 2501ms total,     318 ops/sec\n GET 4MiB buf,  batch 20/1 avg/max:  65.91/ 87.59 2572ms total,     303 ops/sec\n```\n\n## Debugging\n\nTo get debug output run your Node Redis application with `NODE_DEBUG=redis`.\n\nThis is also going to result in good stack traces opposed to useless ones\notherwise for any async operation.\nIf you only want to have good stack traces but not the debug output run your\napplication in development mode instead (`NODE_ENV=development`).\n\nGood stack traces are only activated in development and debug mode as this\nresults in a significant performance penalty.\n\n**_Comparison_**:\n\nStandard stack trace:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at parseError (/home/ruben/repos/redis/node_modules/redis-parser/lib/parser.js:158:12)\n    at parseType (/home/ruben/repos/redis/node_modules/redis-parser/lib/parser.js:219:14)\n```\n\nDebug stack trace:\n\n```\nReplyError: ERR wrong number of arguments for 'set' command\n    at new Command (/home/ruben/repos/redis/lib/command.js:9:902)\n    at RedisClient.set (/home/ruben/repos/redis/lib/commands.js:9:3238)\n    at Context.<anonymous> (/home/ruben/repos/redis/test/good_stacks.spec.js:20:20)\n    at callFnAsync (/home/ruben/repos/redis/node_modules/mocha/lib/runnable.js:349:8)\n    at Test.Runnable.run (/home/ruben/repos/redis/node_modules/mocha/lib/runnable.js:301:7)\n    at Runner.runTest (/home/ruben/repos/redis/node_modules/mocha/lib/runner.js:422:10)\n    at /home/ruben/repos/redis/node_modules/mocha/lib/runner.js:528:12\n    at next (/home/ruben/repos/redis/node_modules/mocha/lib/runner.js:342:14)\n    at /home/ruben/repos/redis/node_modules/mocha/lib/runner.js:352:7\n    at next (/home/ruben/repos/redis/node_modules/mocha/lib/runner.js:284:14)\n    at Immediate._onImmediate (/home/ruben/repos/redis/node_modules/mocha/lib/runner.js:320:5)\n    at processImmediate [as _immediateCallback] (timers.js:383:17)\n```\n\n## Contributing\n\nPlease see the [contributing guide](CONTRIBUTING.md).\n\n## License\n\nThis repository is licensed under the \"MIT\" license. See [LICENSE](LICENSE).\n",
    "licenseText": "MIT License\n\nCopyright (c) 2016-present Node Redis contributors.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/redis/-/redis-3.1.2.tgz#766851117e80653d23e0ed536254677ab647638c",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/redis/-/redis-3.1.2.tgz",
    "hash": "766851117e80653d23e0ed536254677ab647638c",
    "integrity": "sha512-grn5KoZLr/qrRQVwoSkmzdbw6pwF+/rwODtrOr6vuBRiR/f3rjSTGupbF90Zpqm2oenix8Do6RV7pYEkGwlKkw==",
    "registry": "npm",
    "packageName": "redis",
    "cacheIntegrity": "sha512-grn5KoZLr/qrRQVwoSkmzdbw6pwF+/rwODtrOr6vuBRiR/f3rjSTGupbF90Zpqm2oenix8Do6RV7pYEkGwlKkw== sha1-dmhREX6AZT0j4O1TYlRnerZHY4w="
  },
  "registry": "npm",
  "hash": "766851117e80653d23e0ed536254677ab647638c"
}