{
  "manifest": {
    "name": "react-loadable",
    "version": "5.5.0",
    "description": "A higher order component for loading components with promises",
    "main": "lib/index.js",
    "author": {
      "name": "James Kyle",
      "email": "me@thejameskyle.com"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/thejameskyle/react-loadable.git"
    },
    "files": [
      "babel.js",
      "webpack.js",
      "lib/**"
    ],
    "scripts": {
      "test": "jest --coverage",
      "build": "babel src -d lib",
      "start": "yarn build && webpack && babel-node example/server.js",
      "prepublish": "yarn build"
    },
    "dependencies": {
      "prop-types": "^15.5.0"
    },
    "devDependencies": {
      "babel-cli": "^6.24.1",
      "babel-loader": "^7.1.2",
      "babel-plugin-dynamic-import-node": "^1.1.0",
      "babel-plugin-module-resolver": "^2.7.1",
      "babel-plugin-transform-async-to-generator": "^6.24.1",
      "babel-plugin-transform-class-properties": "^6.24.1",
      "babel-plugin-transform-object-assign": "^6.22.0",
      "babel-preset-es2015": "^6.24.1",
      "babel-preset-react": "^6.24.1",
      "express": "^4.16.1",
      "flow-bin": "^0.41.0",
      "jest": "^21.2.1",
      "react": "^16.0.0",
      "react-dom": "^16.0.0",
      "react-test-renderer": "^16.0.0",
      "webpack": "^3.6.0"
    },
    "peerDependencies": {
      "react": "*"
    },
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-react-loadable-5.5.0-582251679d3da86c32aae2c8e689c59f1196d8c4-integrity/node_modules/react-loadable/package.json",
    "readmeFilename": "README.md",
    "readme": "![React Loadable](http://thejameskyle.com/img/react-loadable-header.png)\n\n> A higher order component for loading components with dynamic imports.\n\n## Install\n\n```sh\nyarn add react-loadable\n```\n\n## Example\n\n```js\nimport Loadable from 'react-loadable';\nimport Loading from './my-loading-component';\n\nconst LoadableComponent = Loadable({\n  loader: () => import('./my-component'),\n  loading: Loading,\n});\n\nexport default class App extends React.Component {\n  render() {\n    return <LoadableComponent/>;\n  }\n}\n```\n\n## Happy Customers:\n\n- [\"I'm obsessed with this right now: CRA with React Router v4 and react-loadable. Free code splitting, this is so easy.\"](https://twitter.com/matzatorski/status/872059865350406144)\n- [\"Webpack 2 upgrade & react-loadable; initial load from 1.1mb to 529kb in under 2 hours. Immense.\"](https://twitter.com/jwbradley87/status/847191118269833216)\n- [\"Oh hey - using loadable component I knocked 13K off my initial load. Easy win!\"](https://twitter.com/AdamRackis/status/846593080992153600)\n- [\"Had a look and its awesome. shaved like 50kb off our main bundle.\"](https://github.com/quran/quran.com-frontend/pull/701#issuecomment-287908551)\n- [\"I've got that server-side rendering + code splitting + PWA ServiceWorker caching setup done ðŸ˜Ž (thanks to react-loadable). Now our frontend is super fast.\"](https://twitter.com/mxstbr/status/922375575217627136)\n- [\"Using react-loadable went from 221.28 KB â†’ 115.76 KB @ main bundle. Fucking awesome and very simple API.\"](https://twitter.com/evgenyrodionov/status/958821614644269057)\n\n## Users\n\n- [Analog.Cafe](https://www.analog.cafe)\n- [Appbase.io](https://github.com/appbaseio/reactivesearch)\n- [Atlassian](https://www.atlassian.com/)\n- [Cloudflare](https://www.cloudflare.com)\n- [Curio](https://www.curio.org)\n- [Dresez](https://dresez.pk/)\n- [Flyhomes](https://flyhomes.com)\n- [Gogo](https://gogoair.com)\n- [Gofore](https://gofore.com/en/home/)\n- [MediaTek MCS-Lite](https://github.com/MCS-Lite)\n- [Officepulse](https://www.officepulse.in/)\n- [Render](https://render.com)\n- [Snipit](https://snipit.io)\n- [Spectrum.chat](https://spectrum.chat)\n- [Talentpair](https://talentpair.com)\n- [Tinder](https://tinder.com/)\n- [Unsplash](https://unsplash.com/)\n- [Wave](https://waveapps.com/)\n\n> _If your company or project is using React Loadable, please open a PR and add\n> yourself to this list (in alphabetical order please)_\n\n## Also See:\n\n- [`react-loadable-visibility`](https://github.com/stratiformltd/react-loadable-visibility) - Building on top of and keeping the same API as `react-loadable`, this library enables you to load content that is visible on the screen.\n\n<h2>\n  <hr>\n  <hr>\n  <img src=\"http://thejameskyle.com/img/react-loadable-guide.png\" alt=\"GUIDE\">\n  <hr>\n  <hr>\n  <small>Guide</small>\n</h2>\n\nSo you've got your React app, you're bundling it with Webpack, and things are\ngoing smooth. But then one day you notice your app's bundle is getting so big\nthat it's slowing things down.\n\nIt's time to start code-splitting your app!\n\n![A single giant bundle vs multiple smaller bundles](http://thejameskyle.com/img/react-loadable-split-bundles.png)\n\nCode-splitting is the process of taking one large bundle containing your entire\napp, and splitting them up into multiple smaller bundles which contain separate\nparts of your app.\n\nThis might seem difficult to do, but tools like Webpack have this built in, and\nReact Loadable is designed to make it super simple.\n\n### Route-based splitting vs. Component-based splitting\n\nA common piece of advice you will see is to break your app into separate routes\nand load each one asynchronously. This seems to work well enough for many appsâ€“\nas a user, clicking a link and waiting for a page to load is a familiar\nexperience on the web.\n\nBut we can do better than that.\n\nUsing most routing tools for React, a route is simply a component. There's\nnothing particularly special about them (Sorry Ryan and Michaelâ€“ you're what's\nspecial). So what if we optimized for splitting around components instead of\nroutes? What would that get us?\n\n![Route vs. component centric code splitting](http://thejameskyle.com/img/react-loadable-component-splitting.png)\n\nAs it turns out: Quite a lot. There are many more places than just routes where\nyou can pretty easily split apart your app. Modals, tabs, and many more UI\ncomponents hide content until the user has done something to reveal it.\n\n> **Example:** Maybe your app has a map buried inside of a tab component. Why\n> would you load a massive mapping library for the parent route every time when\n> the user may never go to that tab?\n\nNot to mention all the places where you can defer loading content until higher\npriority content is finished loading. That component at the bottom of your page\nwhich loads a bunch of libraries: Why should that be loaded at the same time as\nthe content at the top?\n\nAnd because routes are just components, we can still easily code-split at the\nroute level.\n\nIntroducing new code-splitting points in your app should be so easy that you\ndon't think twice about it. It should be a matter of changing a few lines of\ncode and everything else should be automated.\n\n### Introducing React Loadable\n\nReact Loadable is a small library that makes component-centric code splitting\nincredibly easy in React.\n\n`Loadable` is a higher-order component (a function that creates a component)\nwhich lets you dynamically load any module before rendering it into your app.\n\nLet's imagine two components, one that imports and renders another.\n\n```js\nimport Bar from './components/Bar';\n\nclass Foo extends React.Component {\n  render() {\n    return <Bar/>;\n  }\n}\n```\n\nRight now we're depending on `Bar` being imported synchronously via `import`,\nbut we don't need it until we go to render it. So why don't we just defer that?\n\nUsing a **dynamic import** ([a tc39 proposal currently at Stage 3](https://github.com/tc39/proposal-dynamic-import))\nwe can modify our component to load `Bar` asynchronously.\n\n```js\nclass MyComponent extends React.Component {\n  state = {\n    Bar: null\n  };\n\n  componentWillMount() {\n    import('./components/Bar').then(Bar => {\n      this.setState({ Bar });\n    });\n  }\n\n  render() {\n    let {Bar} = this.state;\n    if (!Bar) {\n      return <div>Loading...</div>;\n    } else {\n      return <Bar/>;\n    };\n  }\n}\n```\n\nBut that's a whole bunch of work, and it doesn't even handle a bunch of cases.\nWhat about when `import()` fails? What about server-side rendering?\n\nInstead you can use `Loadable` to abstract away the problem.\n\n```js\nimport Loadable from 'react-loadable';\n\nconst LoadableBar = Loadable({\n  loader: () => import('./components/Bar'),\n  loading() {\n    return <div>Loading...</div>\n  }\n});\n\nclass MyComponent extends React.Component {\n  render() {\n    return <LoadableBar/>;\n  }\n}\n```\n\n### Automatic code-splitting on `import()`\n\nWhen you use `import()` with Webpack 2+, it will\n[automatically code-split](https://webpack.js.org/guides/code-splitting/) for\nyou with no additional configuration.\n\nThis means that you can easily experiment with new code splitting points just\nby switching to `import()` and using React Loadable. Figure out what performs\nbest for your app.\n\n### Creating a great \"Loading...\" Component\n\nRendering a static \"Loading...\" doesn't communicate enough to the user. You\nalso need to think about error states, timeouts, and making it a nice\nexperience.\n\n```js\nfunction Loading() {\n  return <div>Loading...</div>;\n}\n\nLoadable({\n  loader: () => import('./WillFailToLoad'), // oh no!\n  loading: Loading,\n});\n```\n\nTo make this all nice, your [loading component](#loadingcomponent) receives a\ncouple different props.\n\n#### Loading error states\n\nWhen your [`loader`](optsloader) fails, your [loading component](#loadingcomponent)\nwill receive an [`error`](propserror) prop which will be an `Error` object (otherwise it\nwill be `null`).\n\n```js\nfunction Loading(props) {\n  if (props.error) {\n    return <div>Error! <button onClick={ props.retry }>Retry</button></div>;\n  } else {\n    return <div>Loading...</div>;\n  }\n}\n```\n\n#### Avoiding _Flash Of Loading Component_\n\nSometimes components load really quickly (<200ms) and the loading screen only\nquickly flashes on the screen.\n\nA number of user studies have proven that this causes users to perceive things\ntaking longer than they really have. If you don't show anything, users perceive\nit as being faster.\n\nSo your loading component will also get a [`pastDelay` prop](#propspastdelay)\nwhich will only be true once the component has taken longer to load than a set\n[delay](#optsdelay).\n\n```js\nfunction Loading(props) {\n  if (props.error) {\n    return <div>Error! <button onClick={ props.retry }>Retry</button></div>;\n  } else if (props.pastDelay) {\n    return <div>Loading...</div>;\n  } else {\n    return null;\n  }\n}\n```\n\nThis delay defaults to `200ms` but you can also customize the\n[delay](#optsdelay) in `Loadable`.\n\n```js\nLoadable({\n  loader: () => import('./components/Bar'),\n  loading: Loading,\n  delay: 300, // 0.3 seconds\n});\n```\n\n#### Timing out when the `loader` is taking too long\n\nSometimes network connections suck and never resolve or fail, they just hang\nthere forever. This sucks for the user because they won't know if it should\nalways take this long, or if they should try refreshing.\n\nThe [loading component](#loadingcomponent) will receive a\n[`timedOut` prop](#propstimedout) which will be set to `true` when the\n[`loader`](#optsloader) has timed out.\n\n```js\nfunction Loading(props) {\n  if (props.error) {\n    return <div>Error! <button onClick={ props.retry }>Retry</button></div>;\n  } else if (props.timedOut) {\n    return <div>Taking a long time... <button onClick={ props.retry }>Retry</button></div>;\n  } else if (props.pastDelay) {\n    return <div>Loading...</div>;\n  } else {\n    return null;\n  }\n}\n```\n\nHowever, this feature is disabled by default. To turn it on, you can pass a\n[`timeout` option](#optstimeout) to `Loadable`.\n\n```js\nLoadable({\n  loader: () => import('./components/Bar'),\n  loading: Loading,\n  timeout: 10000, // 10 seconds\n});\n```\n\n### Customizing rendering\n\nBy default `Loadable` will render the `default` export of the returned module.\nIf you want to customize this behavior you can use the\n[`render` option](#optsrender).\n\n```js\nLoadable({\n  loader: () => import('./my-component'),\n  render(loaded, props) {\n    let Component = loaded.namedExport;\n    return <Component {...props}/>;\n  }\n});\n```\n\n### Loading multiple resources\n\nTechnically you can do whatever you want within `loader()` as long as it\nreturns a promise and [you're able to render something](#customizing-rendering).\nBut writing it out can be a bit annoying.\n\nTo make it easier to load multiple resources in parallel, you can use\n[`Loadable.Map`](#loadablemap).\n\n```js\nLoadable.Map({\n  loader: {\n    Bar: () => import('./Bar'),\n    i18n: () => fetch('./i18n/bar.json').then(res => res.json()),\n  },\n  render(loaded, props) {\n    let Bar = loaded.Bar.default;\n    let i18n = loaded.i18n;\n    return <Bar {...props} i18n={i18n}/>;\n  },\n});\n```\n\nWhen using `Loadable.Map` the [`render()` method](#optsrender) is required. It\nwill be passed a `loaded` param which will be an object matching the shape of\nyour `loader`.\n\n### Preloading\n\nAs an optimization, you can also decide to preload a component before it gets\nrendered.\n\nFor example, if you need to load a new component when a button gets pressed,\nyou could start preloading the component when the user hovers over the button.\n\nThe component created by `Loadable` exposes a\n[static `preload` method](#loadablecomponentpreload) which does exactly this.\n\n```js\nconst LoadableBar = Loadable({\n  loader: () => import('./Bar'),\n  loading: Loading,\n});\n\nclass MyComponent extends React.Component {\n  state = { showBar: false };\n\n  onClick = () => {\n    this.setState({ showBar: true });\n  };\n\n  onMouseOver = () => {\n    LoadableBar.preload();\n  };\n\n  render() {\n    return (\n      <div>\n        <button\n          onClick={this.onClick}\n          onMouseOver={this.onMouseOver}>\n          Show Bar\n        </button>\n        {this.state.showBar && <LoadableBar/>}\n      </div>\n    )\n  }\n}\n```\n\n<h2>\n  <hr>\n  <hr>\n  <img src=\"http://thejameskyle.com/img/react-loadable-ssr.png\" alt=\"SERVER SIDE RENDERING\">\n  <hr>\n  <hr>\n  <small>Server-Side Rendering</small>\n</h2>\n\nWhen you go to render all these dynamically loaded components, what you'll get\nis a whole bunch of loading screens.\n\nThis really sucks, but the good news is that React Loadable is designed to\nmake server-side rendering work as if nothing is being loaded dynamically.\n\nHere's our starting server using [Express](https://expressjs.com/).\n\n```js\nimport express from 'express';\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport App from './components/App';\n\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send(`\n    <!doctype html>\n    <html lang=\"en\">\n      <head>...</head>\n      <body>\n        <div id=\"app\">${ReactDOMServer.renderToString(<App/>)}</div>\n        <script src=\"/dist/main.js\"></script>\n      </body>\n    </html>\n  `);\n});\n\napp.listen(3000, () => {\n  console.log('Running on http://localhost:3000/');\n});\n```\n\n### Preloading all your loadable components on the server\n\nThe first step to rendering the correct content from the server is to make sure\nthat all of your loadable components are already loaded when you go to render\nthem.\n\nTo do this, you can use the [`Loadable.preloadAll`](#loadablepreloadall)\nmethod. It returns a promise that will resolve when all your loadable\ncomponents are ready.\n\n```js\nLoadable.preloadAll().then(() => {\n  app.listen(3000, () => {\n    console.log('Running on http://localhost:3000/');\n  });\n});\n```\n\n### Picking up a server-side rendered app on the client\n\nThis is where things get a little bit tricky. So let's prepare ourselves\nlittle bit.\n\nIn order for us to pick up what was rendered from the server we need to have\nall the same code that was used to render on the server.\n\nTo do this, we first need our loadable components telling us which modules they\nare rendering.\n\n#### Declaring which modules are being loaded\n\nThere are two options in [`Loadable`](#loadable) and\n[`Loadable.Map`](#loadablemap) which are used to tell us which modules our\ncomponent is trying to load: [`opts.modules`](#optsmodules) and\n[`opts.webpack`](#optswebpack).\n\n```js\nLoadable({\n  loader: () => import('./Bar'),\n  modules: ['./Bar'],\n  webpack: () => [require.resolveWeak('./Bar')],\n});\n```\n\nBut don't worry too much about these options. React Loadable includes a\n[Babel plugin](#babel-plugin) to add them for you.\n\nJust add the `react-loadable/babel` plugin to your Babel config:\n\n```json\n{\n  \"plugins\": [\n    \"react-loadable/babel\"\n  ]\n}\n```\n\nNow these options will automatically be provided.\n\n#### Finding out which dynamic modules were rendered\n\nNext we need to find out which modules were actually rendered when a request\ncomes in.\n\nFor this, there is [`Loadable.Capture`](#loadablecapture) component which can\nbe used to collect all the modules that were rendered.\n\n```js\nimport Loadable from 'react-loadable';\n\napp.get('/', (req, res) => {\n  let modules = [];\n\n  let html = ReactDOMServer.renderToString(\n    <Loadable.Capture report={moduleName => modules.push(moduleName)}>\n      <App/>\n    </Loadable.Capture>\n  );\n\n  console.log(modules);\n\n  res.send(`...${html}...`);\n});\n```\n\n#### Mapping loaded modules to bundles\n\nIn order to make sure that the client loads all the modules that were rendered\nserver-side, we'll need to map them to the bundles that Webpack created.\n\nThis comes in two parts.\n\nFirst we need Webpack to tell us which bundles each module lives inside. For\nthis there is the [React Loadable Webpack plugin](#webpack-plugin).\n\nImport the `ReactLoadablePlugin` from `react-loadable/webpack` and include it\nin your webpack config. Pass it a `filename` for where to store the JSON data\nabout our bundles.\n\n```js\n// webpack.config.js\nimport { ReactLoadablePlugin } from 'react-loadable/webpack';\n\nexport default {\n  plugins: [\n    new ReactLoadablePlugin({\n      filename: './dist/react-loadable.json',\n    }),\n  ],\n};\n```\n\nThen we'll go back to our server and use this data to convert our modules to\nbundles.\n\nTo convert from modules to bundles, import the [`getBundles`](#getbundles)\nmethod from `react-loadable/webpack` and the data from Webpack.\n\n```js\nimport Loadable from 'react-loadable';\nimport { getBundles } from 'react-loadable/webpack'\nimport stats from './dist/react-loadable.json';\n\napp.get('/', (req, res) => {\n  let modules = [];\n\n  let html = ReactDOMServer.renderToString(\n    <Loadable.Capture report={moduleName => modules.push(moduleName)}>\n      <App/>\n    </Loadable.Capture>\n  );\n\n  let bundles = getBundles(stats, modules);\n\n  // ...\n});\n```\n\nWe can then render these bundles into `<script>` tags in our HTML.\n\nIt is important that the bundles are included _before_ the main bundle, so that\nthey can be loaded by the browser prior to the app rendering.\n\nHowever, as the Webpack manifest (including the logic for parsing bundles) lives in\nthe main bundle, it will need to be extracted into its own chunk.\n\nThis is easy to do with the [CommonsChunkPlugin](https://webpack.js.org/plugins/commons-chunk-plugin/)\n\n```js\n// webpack.config.js\nexport default {\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'manifest',\n      minChunks: Infinity\n    })\n  ]\n}\n```\n\n_Notice: As of Webpack 4 the CommonsChunkPlugin has been removed and the manifest doesn't need to be extracted anymore._\n\n```js\nlet bundles = getBundles(stats, modules);\n\nres.send(`\n  <!doctype html>\n  <html lang=\"en\">\n    <head>...</head>\n    <body>\n      <div id=\"app\">${html}</div>\n      <script src=\"/dist/manifest.js\"></script>\n      ${bundles.map(bundle => {\n        return `<script src=\"/dist/${bundle.file}\"></script>`\n        // alternatively if you are using publicPath option in webpack config\n        // you can use the publicPath value from bundle, e.g:\n        // return `<script src=\"${bundle.publicPath}\"></script>`\n      }).join('\\n')}\n      <script src=\"/dist/main.js\"></script>\n    </body>\n  </html>\n`);\n```\n\n#### Preloading ready loadable components on the client\n\nWe can use the [`Loadable.preloadReady()`](#loadablepreloadready) method on the\nclient to preload the loadable components that were included on the page.\n\nLike [`Loadable.preloadAll()`](#loadablepreloadall), it returns a promise,\nwhich on resolution means that we can hydrate our app.\n\n```js\n// src/entry.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Loadable from 'react-loadable';\nimport App from './components/App';\n\nLoadable.preloadReady().then(() => {\n  ReactDOM.hydrate(<App/>, document.getElementById('app'));\n});\n\n```\n\n<h4 align=\"center\">\n  Now server-side rendering should work perfectly!\n</h4>\n\n<h2>\n  <hr>\n  <hr>\n  <img src=\"http://thejameskyle.com/img/react-loadable-api-docs.png\" alt=\"API DOCS\">\n  <hr>\n  <hr>\n  <small>API Docs</small>\n</h2>\n\n### `Loadable`\n\nA higher-order component for dynamically [loading](#optsloader) a module before\n[rendering](#optsrender) it, a [loading](#opts.loading) component is rendered\nwhile the module is unavailable.\n\n```js\nconst LoadableComponent = Loadable({\n  loader: () => import('./Bar'),\n  loading: Loading,\n  delay: 200,\n  timeout: 10000,\n});\n```\n\nThis returns a [LoadableComponent](#loadablecomponent).\n\n### `Loadable.Map`\n\nA higher-order component that allows you to load multiple resources in parallel.\n\nLoadable.Map's [`opts.loader`](#optsloader) accepts an object of functions, and\nneeds a [`opts.render`](#optsrender) method.\n\n```js\nLoadable.Map({\n  loader: {\n    Bar: () => import('./Bar'),\n    i18n: () => fetch('./i18n/bar.json').then(res => res.json()),\n  },\n  render(loaded, props) {\n    let Bar = loaded.Bar.default;\n    let i18n = loaded.i18n;\n    return <Bar {...props} i18n={i18n}/>;\n  }\n});\n```\n\nWhen using `Loadable.Map` the `render()` method's `loaded` param will be an\nobject with the same shape as your `loader`.\n\n### `Loadable` and `Loadable.Map` Options\n\n#### `opts.loader`\n\nA function returning a promise that loads your module.\n\n```js\nLoadable({\n  loader: () => import('./Bar'),\n});\n```\n\nWhen using with [`Loadable.Map`](#loadablemap) this accepts an object of these\ntypes of functions.\n\n```js\nLoadable.Map({\n  loader: {\n    Bar: () => import('./Bar'),\n    i18n: () => fetch('./i18n/bar.json').then(res => res.json()),\n  },\n});\n```\n\nWhen using with `Loadable.Map` you'll also need to pass a\n[`opts.render`](#optsrender) function.\n\n#### `opts.loading`\n\nA [`LoadingComponent`](#loadingcomponent) that renders while a module is\nloading or when it errors.\n\n```js\nLoadable({\n  loading: LoadingComponent,\n});\n```\n\nThis option is required, if you don't want to render anything, return `null`.\n\n```js\nLoadable({\n  loading: () => null,\n});\n```\n\n#### `opts.delay`\n\nTime to wait (in milliseconds) before passing\n[`props.pastDelay`](#propspastdelay) to your [`loading`](#optsloading)\ncomponent. This defaults to `200`.\n\n```js\nLoadable({\n  delay: 200\n});\n```\n\n[Read more about delays](#avoiding-flash-of-loading-component).\n\n#### `opts.timeout`\n\nTime to wait (in milliseconds) before passing\n[`props.timedOut`](#propstimedout) to your [`loading`](#optsloading) component.\nThis is turned off by default.\n\n```js\nLoadable({\n  timeout: 10000\n});\n```\n\n[Read more about timeouts](#timing-out-when-the-loader-is-taking-too-long).\n\n#### `opts.render`\n\nA function to customize the rendering of loaded modules.\n\nReceives `loaded` which is the resolved value of [`opts.loader`](#optsloader)\nand `props` which are the props passed to the\n[`LoadableComponent`](#loadablecomponent).\n\n```js\nLoadable({\n  render(loaded, props) {\n    let Component = loaded.default;\n    return <Component {...props}/>;\n  }\n});\n```\n\n#### `opts.webpack`\n\nAn optional function which returns an array of Webpack module ids which you can\nget with `require.resolveWeak`.\n\n```js\nLoadable({\n  loader: () => import('./Foo'),\n  webpack: () => [require.resolveWeak('./Foo')],\n});\n```\n\nThis option can be automated with the [Babel Plugin](#babel-plugin).\n\n#### `opts.modules`\n\nAn optional array with module paths for your imports.\n\n```js\nLoadable({\n  loader: () => import('./my-component'),\n  modules: ['./my-component'],\n});\n```\n\nThis option can be automated with the [Babel Plugin](#babel-plugin).\n\n### `LoadableComponent`\n\nThis is the component returned by `Loadable` and `Loadable.Map`.\n\n```js\nconst LoadableComponent = Loadable({\n  // ...\n});\n```\n\nProps passed to this component will be passed straight through to the\ndynamically loaded component via [`opts.render`](#optsrender).\n\n#### `LoadableComponent.preload()`\n\nThis is a static method on [`LoadableComponent`](#loadablecomponent) which can\nbe used to load the component ahead of time.\n\n```js\nconst LoadableComponent = Loadable({...});\n\nLoadableComponent.preload();\n```\n\nThis returns a promise, but you should avoid waiting for that promise to\nresolve to update your UI. In most cases it creates a bad user experience.\n\n[Read more about preloading](#preloading).\n\n### `LoadingComponent`\n\nThis is the component you pass to [`opts.loading`](#optsloading).\n\n```js\nfunction LoadingComponent(props) {\n  if (props.error) {\n    // When the loader has errored\n    return <div>Error! <button onClick={ props.retry }>Retry</button></div>;\n  } else if (props.timedOut) {\n    // When the loader has taken longer than the timeout\n    return <div>Taking a long time... <button onClick={ props.retry }>Retry</button></div>;\n  } else if (props.pastDelay) {\n    // When the loader has taken longer than the delay\n    return <div>Loading...</div>;\n  } else {\n    // When the loader has just started\n    return null;\n  }\n}\n\nLoading({\n  loading: LoadingComponent,\n});\n```\n\n[Read more about loading components](#creating-a-great-loading-component)\n\n#### `props.error`\n\nAn `Error` object passed to [`LoadingComponent`](#loadingcomponent) when the\n[`loader`](#optsloader) has failed. When there is no error, `null` is\npassed.\n\n```js\nfunction LoadingComponent(props) {\n  if (props.error) {\n    return <div>Error!</div>;\n  } else {\n    return <div>Loading...</div>;\n  }\n}\n```\n\n[Read more about errors](#loading-error-states).\n\n#### `props.retry`\n\nA function prop passed to [`LoadingComponent`](#loadingcomponent) when the\n[`loader`](#optsloader) has failed, used to retry loading the component.\n\n```js\nfunction LoadingComponent(props) {\n  if (props.error) {\n    return <div>Error! <button onClick={ props.retry }>Retry</button></div>;\n  } else {\n    return <div>Loading...</div>;\n  }\n}\n```\n\n[Read more about errors](#loading-error-states).\n\n#### `props.timedOut`\n\nA boolean prop passed to [`LoadingComponent`](#loadingcomponent) after a set\n[`timeout`](#optstimeout).\n\n```js\nfunction LoadingComponent(props) {\n  if (props.timedOut) {\n    return <div>Taking a long time...</div>;\n  } else {\n    return <div>Loading...</div>;\n  }\n}\n```\n\n[Read more about timeouts](#timing-out-when-the-loader-is-taking-too-long).\n\n#### `props.pastDelay`\n\nA boolean prop passed to [`LoadingComponent`](#loadingcomponent) after a set\n[`delay`](#optsdelay).\n\n```js\nfunction LoadingComponent(props) {\n  if (props.pastDelay) {\n    return <div>Loading...</div>;\n  } else {\n    return null;\n  }\n}\n```\n\n[Read more about delays](#avoiding-flash-of-loading-component).\n\n### `Loadable.preloadAll()`\n\nThis will call all of the\n[`LoadableComponent.preload`](#loadablecomponentpreload) methods recursively\nuntil they are all resolved. Allowing you to preload all of your dynamic\nmodules in environments like the server.\n\n```js\nLoadable.preloadAll().then(() => {\n  app.listen(3000, () => {\n    console.log('Running on http://localhost:3000/');\n  });\n});\n```\n\nIt's important to note that this requires that you declare all of your loadable\ncomponents when modules are initialized rather than when your app is being\nrendered.\n\n**Good:**\n\n```js\n// During module initialization...\nconst LoadableComponent = Loadable({...});\n\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    // ...\n  }\n}\n```\n\n**Bad:**\n\n```js\n// ...\n\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    // During app render...\n    const LoadableComponent = Loadable({...});\n  }\n}\n```\n\n> **Note:** `Loadable.preloadAll()` will not work if you have more than one\n> copy of `react-loadable` in your app.\n\n[Read more about preloading on the server](#preloading-all-your-loadable-components-on-the-server).\n\n### `Loadable.preloadReady()`\n\nCheck for modules that are already loaded in the browser and call the matching\n[`LoadableComponent.preload`](#loadablecomponentpreload) methods.\n\n```js\nLoadable.preloadReady().then(() => {\n  ReactDOM.hydrate(<App/>, document.getElementById('app'));\n});\n```\n\n[Read more about preloading on the client](#waiting-to-render-on-the-client-until-all-the-bundles-are-loaded).\n\n### `Loadable.Capture`\n\nA component for reporting which modules were rendered.\n\nAccepts a `report` prop which is called for every `moduleName` that is\nrendered via React Loadable.\n\n```js\nlet modules = [];\n\nlet html = ReactDOMServer.renderToString(\n  <Loadable.Capture report={moduleName => modules.push(moduleName)}>\n    <App/>\n  </Loadable.Capture>\n);\n\nconsole.log(modules);\n```\n\n[Read more about capturing rendered modules](#finding-out-which-dynamic-modules-were-rendered).\n\n## Babel Plugin\n\nProviding [`opts.webpack`](#optswebpack) and [`opts.modules`](#optsmodules) for\nevery loadable component is a lot of manual work to remember to do.\n\nInstead you can add the Babel plugin to your config and it will automate it for\nyou:\n\n```json\n{\n  \"plugins\": [\"react-loadable/babel\"]\n}\n```\n\n**Input**\n\n```js\nimport Loadable from 'react-loadable';\n\nconst LoadableMyComponent = Loadable({\n  loader: () => import('./MyComponent'),\n});\n\nconst LoadableComponents = Loadable.Map({\n  loader: {\n    One: () => import('./One'),\n    Two: () => import('./Two'),\n  },\n});\n```\n\n**Output**\n\n```js\nimport Loadable from 'react-loadable';\nimport path from 'path';\n\nconst LoadableMyComponent = Loadable({\n  loader: () => import('./MyComponent'),\n  webpack: () => [require.resolveWeak('./MyComponent')],\n  modules: [path.join(__dirname, './MyComponent')],\n});\n\nconst LoadableComponents = Loadable.Map({\n  loader: {\n    One: () => import('./One'),\n    Two: () => import('./Two'),\n  },\n  webpack: () => [require.resolveWeak('./One'), require.resolveWeak('./Two')],\n  modules: [path.join(__dirname, './One'), path.join(__dirname, './Two')],\n});\n```\n\n[Read more about declaring modules](#declaring-which-modules-are-being-loaded).\n\n## Webpack Plugin\n\nIn order to [send the right bundles down](#mapping-loaded-modules-to-bundles)\nwhen rendering server-side, you'll need the React Loadable Webpack pluginÂ \nto provide you with a mapping of modules to bundles.\n\n```js\n// webpack.config.js\nimport { ReactLoadablePlugin } from 'react-loadable/webpack';\n\nexport default {\n  plugins: [\n    new ReactLoadablePlugin({\n      filename: './dist/react-loadable.json',\n    }),\n  ],\n};\n```\n\nThis will create a file (`opts.filename`) which you can import to map modules\nto bundles.\n\n[Read more about mapping modules to bundles](#mapping-loaded-modules-to-bundles).\n\n### `getBundles`\n\nA method exported by `react-loadable/webpack` for converting modules to\nbundles.\n\n```js\nimport { getBundles } from 'react-loadable/webpack';\n\nlet bundles = getBundles(stats, modules);\n```\n\n[Read more about mapping modules to bundles](#mapping-loaded-modules-to-bundles).\n\n<h2>\n  <hr>\n  <hr>\n  <img src=\"http://thejameskyle.com/img/react-loadable-faq.png\" alt=\"FAQ\">\n  <hr>\n  <hr>\n  <small>FAQ</small>\n</h2>\n\n### How do I avoid repetition?\n\nSpecifying the same `loading` component or `delay` every time you use\n`Loadable()` gets repetitive fast. Instead you can wrap `Loadable` with your\nown Higher-Order Component (HOC) to set default options.\n\n```js\nimport Loadable from 'react-loadable';\nimport Loading from './my-loading-component';\n\nexport default function MyLoadable(opts) {\n  return Loadable(Object.assign({\n    loading: Loading,\n    delay: 200,\n    timeout: 10000,\n  }, opts));\n};\n```\n\nThen you can just specify a `loader` when you go to use it.\n\n```js\nimport MyLoadable from './MyLoadable';\n\nconst LoadableMyComponent = MyLoadable({\n  loader: () => import('./MyComponent'),\n});\n\nexport default class App extends React.Component {\n  render() {\n    return <LoadableMyComponent/>;\n  }\n}\n```\n\nUnfortunately at the moment using wrapped Loadable breaks [react-loadable/babel](#babel-plugin) so in such case you have to add required properties (`modules`, `webpack`) manually.\n\n```js\nimport MyLoadable from './MyLoadable';\n\nconst LoadableMyComponent = MyLoadable({\n  loader: () => import('./MyComponent'),\n  modules: ['./MyComponent'],\n  webpack: () => [require.resolveWeak('./MyComponent')],\n});\n\nexport default class App extends React.Component {\n  render() {\n    return <LoadableMyComponent/>;\n  }\n}\n```\n\n### How do I handle other styles `.css` or sourcemaps `.map` with server-side rendering?\n\nWhen you call [`getBundles`](#getbundles), it may return file types other than\nJavaScript depending on your Webpack configuration.\n\nTo handle this, you should manually filter down to the file extensions that\nyou care about:\n\n```js\nlet bundles = getBundles(stats, modules);\n\nlet styles = bundles.filter(bundle => bundle.file.endsWith('.css'));\nlet scripts = bundles.filter(bundle => bundle.file.endsWith('.js'));\n\nres.send(`\n  <!doctype html>\n  <html lang=\"en\">\n    <head>\n      ...\n      ${styles.map(style => {\n        return `<link href=\"/dist/${style.file}\" rel=\"stylesheet\"/>`\n      }).join('\\n')}\n    </head>\n    <body>\n      <div id=\"app\">${html}</div>\n      <script src=\"/dist/main.js\"></script>\n      ${scripts.map(script => {\n        return `<script src=\"/dist/${script.file}\"></script>`\n      }).join('\\n')}\n    </body>\n  </html>\n`);\n```\n",
    "licenseText": "COPYRIGHT (c) 2017-present James Kyle <me@thejameskyle.com>\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/react-loadable/-/react-loadable-5.5.0.tgz#582251679d3da86c32aae2c8e689c59f1196d8c4",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/react-loadable/-/react-loadable-5.5.0.tgz",
    "hash": "582251679d3da86c32aae2c8e689c59f1196d8c4",
    "integrity": "sha512-C8Aui0ZpMd4KokxRdVAm2bQtI03k2RMRNzOB+IipV3yxFTSVICv7WoUr5L9ALB5BmKO1iHgZtWM8EvYG83otdg==",
    "registry": "npm",
    "packageName": "react-loadable",
    "cacheIntegrity": "sha512-C8Aui0ZpMd4KokxRdVAm2bQtI03k2RMRNzOB+IipV3yxFTSVICv7WoUr5L9ALB5BmKO1iHgZtWM8EvYG83otdg== sha1-WCJRZ509qGwyquLI5onFnxGW2MQ="
  },
  "registry": "npm",
  "hash": "582251679d3da86c32aae2c8e689c59f1196d8c4"
}